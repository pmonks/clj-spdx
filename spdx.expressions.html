<!DOCTYPE html PUBLIC ""
    "">

<html><head><meta charset="UTF-8" /><title>spdx.expressions documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>spdx</span></div></div></li><li class="depth-2 branch"><a href="spdx.exceptions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>exceptions</span></div></a></li><li class="depth-2 branch current"><a href="spdx.expressions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>expressions</span></div></a></li><li class="depth-2 branch"><a href="spdx.licenses.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>licenses</span></div></a></li><li class="depth-2"><a href="spdx.matching.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>matching</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="spdx.expressions.html#var-compound.3F"><div class="inner"><span>compound?</span></div></a></li><li class="depth-1"><a href="spdx.expressions.html#var-extract-ids"><div class="inner"><span>extract-ids</span></div></a></li><li class="depth-1"><a href="spdx.expressions.html#var-init.21"><div class="inner"><span>init!</span></div></a></li><li class="depth-1"><a href="spdx.expressions.html#var-normalise"><div class="inner"><span>normalise</span></div></a></li><li class="depth-1"><a href="spdx.expressions.html#var-parse"><div class="inner"><span>parse</span></div></a></li><li class="depth-1"><a href="spdx.expressions.html#var-parse-with-info"><div class="inner"><span>parse-with-info</span></div></a></li><li class="depth-1"><a href="spdx.expressions.html#var-simple.3F"><div class="inner"><span>simple?</span></div></a></li><li class="depth-1"><a href="spdx.expressions.html#var-unparse"><div class="inner"><span>unparse</span></div></a></li><li class="depth-1"><a href="spdx.expressions.html#var-valid.3F"><div class="inner"><span>valid?</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">spdx.expressions</h1><div class="doc"><div class="markdown"><p>SPDX license expression functionality. This functionality is bespoke (it does not use the parser in <code>Spdx-Java-Library</code>).</p>
</div></div><div class="public anchor" id="var-compound.3F"><h3>compound?</h3><div class="usage"><code>(compound? s)</code><code>(compound? s opts)</code></div><div class="doc"><div class="markdown"><p>Is <code>s</code> (a <code>String</code>) a ‘compound’ SPDX license expression (i.e. one that contains at least one AND or OR operator)?  Returns <code>nil</code> if <code>s</code> not a valid SPDX expression.</p>
<p>The optional <code>opts</code> map is as for <code>parse</code>.</p>
</div></div><div class="src-link"><a href="https://github.com/pmonks/clj-spdx/blob/release/src/spdx/expressions.clj#L480">view source</a></div></div><div class="public anchor" id="var-extract-ids"><h3>extract-ids</h3><div class="usage"><code>(extract-ids parse-result)</code><code>(extract-ids parse-result {:keys [include-or-later?], :or {include-or-later? false}, :as opts})</code></div><div class="doc"><div class="markdown"><p>Extract all SPDX ids (as a set of <code>String</code>s) from <code>parse-result</code>.</p>
<p>The optional <code>opts</code> map has these keys:</p>
<ul>
<li><code>:include-or-later?</code> (<code>boolean</code>, default <code>false</code>) - controls whether the output includes the ‘or later’ indicator (<code>+</code>) after license ids that have that designation in the parse tree.</li>
</ul>
</div></div><div class="src-link"><a href="https://github.com/pmonks/clj-spdx/blob/release/src/spdx/expressions.clj#L492">view source</a></div></div><div class="public anchor" id="var-init.21"><h3>init!</h3><div class="usage"><code>(init!)</code></div><div class="doc"><div class="markdown"><p>Initialises this namespace upon first call (and does nothing on subsequent calls), returning <code>nil</code>. Consumers of this namespace are not required to call this fn, as initialisation will occur implicitly anyway; it is provided to allow explicit control of the cost of initialisation to callers who need it.</p>
<p>Note: this method may have a substantial performance cost.</p>
</div></div><div class="src-link"><a href="https://github.com/pmonks/clj-spdx/blob/release/src/spdx/expressions.clj#L511">view source</a></div></div><div class="public anchor" id="var-normalise"><h3>normalise</h3><div class="usage"><code>(normalise s)</code><code>(normalise s opts)</code></div><div class="doc"><div class="markdown"><p>Normalises an SPDX expression, by running it through <a href="spdx.expressions.html#var-parse">parse</a> then <a href="spdx.expressions.html#var-unparse">unparse</a>.  Returns <code>nil</code> if <code>s</code> is not a valid SPDX expression.</p>
<p><code>opts</code> are as for <a href="spdx.expressions.html#var-parse">parse</a></p>
</div></div><div class="src-link"><a href="https://github.com/pmonks/clj-spdx/blob/release/src/spdx/expressions.clj#L438">view source</a></div></div><div class="public anchor" id="var-parse"><h3>parse</h3><div class="usage"><code>(parse s)</code><code>(parse s {:keys [normalise-gpl-ids? case-sensitive-operators? collapse-redundant-clauses? sort-licenses?], :or {normalise-gpl-ids? true, case-sensitive-operators? false, collapse-redundant-clauses? true, sort-licenses? true}, :as opts})</code></div><div class="doc"><div class="markdown"><p>Attempt to parse <code>s</code> (a <code>String</code>) as an <a href="https://spdx.github.io/spdx-spec/v3.0/annexes/SPDX-license-expressions/">SPDX license expression</a>, returning a data structure representing the parse tree, or <code>nil</code> if it cannot be parsed.</p>
<p>The optional <code>opts</code> map has these keys:</p>
<ul>
<li><code>:normalise-gpl-ids?</code> (<code>boolean</code>, default <code>true</code>) - controls whether deprecated ‘historical oddity’ GPL family ids in the expression are normalised to their non-deprecated replacements as part of the parsing process.</li>
<li><code>:case-sensitive-operators?</code> (<code>boolean</code>, default <code>false</code>) - controls whether operators in expressions (<code>AND</code>, <code>OR</code>, <code>WITH</code>) are case-sensitive (spec-compliant, but strict) or not (non-spec-compliant, lenient).</li>
<li><code>:collapse-redundant-clauses?</code> (<code>boolean</code>, default <code>true</code>) - controls whether redundant clauses (e.g. “Apache-2.0 AND Apache-2.0”) are collapsed during parsing.</li>
<li><code>:sort-licenses?</code> (<code>boolean</code>, default <code>true</code>) - controls whether licenses that appear at the same level in the parse tree are sorted alphabetically. This means that some parse trees will be identical for different (though logically identical) inputs, which can be useful in many cases.  For example the parse tree for <code>Apache-2.0 OR MIT</code> would be identical to the parse tree for <code>MIT OR Apache-2.0</code>.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The parser always normalises SPDX ids to their canonical case e.g. <code>aPAcHe-2.0</code> -&gt; <code>Apache-2.0</code></li>
<li>The parser always removes redundant grouping e.g. <code>(((((Apache-2.0))))))</code> -&gt; <code>Apache-2.0</code></li>
<li>The parser synthesises grouping when needed to make SPDX license expressions’ precedence rules explicit (see <a href="https://spdx.github.io/spdx-spec/v3.0/annexes/SPDX-license-expressions/#d45-order-of-precedence-and-parentheses">the relevant section within annex D of the SPDX specification</a> for details).</li>
<li>The default <code>opts</code> result in parsing that is more lenient than the SPDX specification and is therefore not strictly spec compliant.  You can enable strictly spec compliant parsing by setting <code>normalise-gpl-ids?</code> to <code>false</code> and <code>case-sensitive-operators?</code> to <code>true</code>.</li>
</ul>
<p>Examples (assuming default options):</p>
<pre><code class="language-clojure">(parse "Apache-2.0")
{:license-id "Apache-2.0"}

(parse "apache-2.0+")
{:license-id "Apache-2.0" :or-later? true}  ; Note id case correction

(parse "GPL-2.0+")
{:license-id "GPL-2.0-or-later"}  ; Note GPL-family id normalisation

(parse "GPL-2.0 WITH Classpath-exception-2.0")
{:license-id "GPL-2.0-only"
 :license-exception-id "Classpath-exception-2.0"}

(parse "CDDL-1.1 or (GPL-2.0+ with Classpath-exception-2.0)")
[:or
 {:license-id "CDDL-1.1"}
 {:license-id "GPL-2.0-or-later"
  :license-exception-id "Classpath-exception-2.0"}]

(parse "DocumentRef-foo:LicenseRef-bar")
{:document-ref "foo"
 :license-ref "bar"}

(parse "Apache-2.0 with DocumentRef-foo:AdditionRef-bar")
{:license-id "Apache-2.0"
 :addition-document-ref "foo"
 :addition-ref "bar"}
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/pmonks/clj-spdx/blob/release/src/spdx/expressions.clj#L354">view source</a></div></div><div class="public anchor" id="var-parse-with-info"><h3>parse-with-info</h3><div class="usage"><code>(parse-with-info s)</code><code>(parse-with-info s {:keys [normalise-gpl-ids? case-sensitive-operators? collapse-redundant-clauses? sort-licenses?], :or {normalise-gpl-ids? true, case-sensitive-operators? false, collapse-redundant-clauses? true, sort-licenses? true}})</code></div><div class="doc"><div class="markdown"><p>As for <a href="spdx.expressions.html#var-parse">parse</a>, but returns an <a href="https://github.com/Engelberg/instaparse#parse-errors">instaparse parse error</a> if parsing fails, instead of <code>nil</code>.</p>
<p><code>opts</code> are as for <a href="spdx.expressions.html#var-parse">parse</a></p>
</div></div><div class="src-link"><a href="https://github.com/pmonks/clj-spdx/blob/release/src/spdx/expressions.clj#L309">view source</a></div></div><div class="public anchor" id="var-simple.3F"><h3>simple?</h3><div class="usage"><code>(simple? s)</code><code>(simple? s opts)</code></div><div class="doc"><div class="markdown"><p>Is <code>s</code> (a <code>String</code>) a ‘simple’ SPDX license expression (i.e. one that contains no AND or OR operators, though it may contain a WITH operator)? Returns <code>nil</code> if <code>s</code> not a valid SPDX expression.</p>
<p>The optional <code>opts</code> map is as for <code>parse</code>.</p>
</div></div><div class="src-link"><a href="https://github.com/pmonks/clj-spdx/blob/release/src/spdx/expressions.clj#L468">view source</a></div></div><div class="public anchor" id="var-unparse"><h3>unparse</h3><div class="usage"><code>(unparse parse-result)</code></div><div class="doc"><div class="markdown"><p>Turns a valid <code>parse-result</code> (i.e. obtained from <a href="spdx.expressions.html#var-parse">parse</a>) back into an SPDX expression (a <code>String</code>), or <code>nil</code> if <code>parse-result</code> is <code>nil</code>.  Results are undefined for invalid parse trees.</p>
</div></div><div class="src-link"><a href="https://github.com/pmonks/clj-spdx/blob/release/src/spdx/expressions.clj#L186">view source</a></div></div><div class="public anchor" id="var-valid.3F"><h3>valid?</h3><div class="usage"><code>(valid? s)</code><code>(valid? s {:keys [case-sensitive-operators?], :or {case-sensitive-operators? false}})</code></div><div class="doc"><div class="markdown"><p>Is <code>s</code> (a <code>String</code>) a valid SPDX license expression?</p>
<p>Note: if you intend to parse <code>s</code> if it’s valid, it’s more efficient to call <a href="spdx.expressions.html#var-parse">parse</a> directly and check for a <code>nil</code> result instead of calling this method first (doing so avoids double parsing).</p>
<p>The optional <code>opts</code> map has these keys:</p>
<ul>
<li><code>:case-sensitive-operators?</code> (<code>boolean</code>, default <code>false</code>) - controls whether operators in expressions (<code>AND</code>, <code>OR</code>, <code>WITH</code>) are case-sensitive (spec-compliant, but strict) or not (non-spec-compliant, lenient).</li>
</ul>
</div></div><div class="src-link"><a href="https://github.com/pmonks/clj-spdx/blob/release/src/spdx/expressions.clj#L449">view source</a></div></div></div></body></html>